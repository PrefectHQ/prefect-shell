{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Integrating shell commands into your dataflow with <code>prefect-shell</code>","text":"<p>The prefect-shell collection makes it easy to execute shell commands in your Prefect flows. Check out the examples below to get started!</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#integrate-with-prefect-flows","title":"Integrate with Prefect flows","text":"<p>With prefect-shell, you can bring your trusty shell commands (and/or scripts) straight into the Prefect flow party, complete with awesome Prefect logging.</p> <p>No more separate logs, just seamless integration. Let's get the shell-abration started!</p> <pre><code>from prefect import flow\nfrom datetime import datetime\nfrom prefect_shell import ShellOperation\n\n@flow\ndef download_data():\n    today = datetime.today().strftime(\"%Y%m%d\")\n\n    # for short running operations, you can use the `run` method\n    # which automatically manages the context\n    ShellOperation(\n        commands=[\n            \"mkdir -p data\",\n            \"mkdir -p data/${today}\"\n        ],\n        env={\"today\": today}\n    ).run()\n\n    # for long running operations, you can use a context manager\n    with ShellOperation(\n        commands=[\n            \"curl -O https://masie_web.apps.nsidc.org/pub/DATASETS/NOAA/G02135/north/daily/data/N_seaice_extent_daily_v3.0.csv\",\n        ],\n        working_dir=f\"data/{today}\",\n    ) as download_csv_operation:\n\n        # trigger runs the process in the background\n        download_csv_process = download_csv_operation.trigger()\n\n        # then do other things here in the meantime, like download another file\n        ...\n\n        # when you're ready, wait for the process to finish\n        download_csv_process.wait_for_completion()\n\n        # if you'd like to get the output lines, you can use the `fetch_result` method\n        output_lines = download_csv_process.fetch_result()\n\ndownload_data()\n</code></pre> <p>Outputs: <pre><code>14:48:16.550 | INFO    | prefect.engine - Created flow run 'tentacled-chachalaca' for flow 'download-data'\n14:48:17.977 | INFO    | Flow run 'tentacled-chachalaca' - PID 19360 triggered with 2 commands running inside the '.' directory.\n14:48:17.987 | INFO    | Flow run 'tentacled-chachalaca' - PID 19360 completed with return code 0.\n14:48:17.994 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 triggered with 1 commands running inside the PosixPath('data/20230201') directory.\n14:48:18.009 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dl\n14:48:18.010 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\noad  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n14:48:18.840 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\n 11 1630k   11  192k    0     0   229k      0  0:00:07 --:--:--  0:00:07  231k\n14:48:19.839 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\n 83 1630k   83 1368k    0     0   745k      0  0:00:02  0:00:01  0:00:01  747k\n14:48:19.993 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\n100 1630k  100 1630k    0     0   819k      0  0\n14:48:19.994 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 stream output:\n:00:01  0:00:01 --:--:--  821k\n14:48:19.996 | INFO    | Flow run 'tentacled-chachalaca' - PID 19363 completed with return code 0.\n14:48:19.998 | INFO    | Flow run 'tentacled-chachalaca' - Successfully closed all open processes.\n14:48:20.203 | INFO    | Flow run 'tentacled-chachalaca' - Finished in state Completed()\n</code></pre></p> <p>Utilize Previously Saved Blocks</p> <p>You can save commands within a <code>ShellOperation</code> block, then reuse them across multiple flows, or even plain Python scripts.</p> <p>Save the block with desired commands:</p> <pre><code>from prefect_shell import ShellOperation\n\nping_op = ShellOperation(commands=[\"ping -t 1 prefect.io\"])\nping_op.save(\"block-name\")\n</code></pre> <p>Load the saved block:</p> <pre><code>from prefect_shell import ShellOperation\n\nping_op = ShellOperation.load(\"block-name\")\n</code></pre> <p>To view and edit the blocks on Prefect UI:</p> <pre><code>prefect block register -m prefect_shell\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-shell</code> with <code>pip</code>:</p> <pre><code>pip install -U prefect-shell\n</code></pre> <p>A list of available blocks in <code>prefect-shell</code> and their setup instructions can be found here.</p> <p>Requires an installation of Python 3.7+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>If you encounter any bugs while using <code>prefect-shell</code>, feel free to open an issue in the prefect-shell repository.</p> <p>If you have any questions or issues while using <code>prefect-shell</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-shell</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-shell</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <pre><code>pre-commit install\n</code></pre></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request</li> </ol>"},{"location":"blocks_catalog/","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-shell</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud: <pre><code>prefect block register -m prefect_shell\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"blocks_catalog/#commands-module","title":"Commands Module","text":"<p>ShellOperation</p> <p>A block representing a shell operation, containing multiple commands.</p> <p>For long-lasting operations, use the trigger method and utilize the block as a context manager for automatic closure of processes when context is exited. If not, manually call the close method to close processes.</p> <p>For short-lasting operations, use the run method. Context is automatically managed with this method.</p> <p>To load the ShellOperation: <pre><code>from prefect import flow\nfrom prefect_shell.commands import ShellOperation\n\n@flow\ndef my_flow():\n    my_block = ShellOperation.load(\"block-name\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Commands Module under Examples Catalog.</p>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#prefect_shell.commands","title":"<code>prefect_shell.commands</code>","text":"<p>Tasks for interacting with shell commands</p>"},{"location":"commands/#prefect_shell.commands-classes","title":"Classes","text":""},{"location":"commands/#prefect_shell.commands.ShellOperation","title":"<code>ShellOperation</code>","text":"<p>             Bases: <code>JobBlock</code></p> <p>A block representing a shell operation, containing multiple commands.</p> <p>For long-lasting operations, use the trigger method and utilize the block as a context manager for automatic closure of processes when context is exited. If not, manually call the close method to close processes.</p> <p>For short-lasting operations, use the run method. Context is automatically managed with this method.</p> <p>Attributes:</p> Name Type Description <code>commands</code> <code>List[str]</code> <p>A list of commands to execute sequentially.</p> <code>stream_output</code> <code>bool</code> <p>Whether to stream output.</p> <code>env</code> <code>Dict[str, str]</code> <p>A dictionary of environment variables to set for the shell operation.</p> <code>working_dir</code> <code>DirectoryPath</code> <p>The working directory context the commands will be executed within.</p> <code>shell</code> <code>str</code> <p>The shell to use to execute the commands.</p> <code>extension</code> <code>Optional[str]</code> <p>The extension to use for the temporary file. if unset defaults to <code>.ps1</code> on Windows and <code>.sh</code> on other platforms.</p> <p>Examples:</p> <p>Load a configured block: <pre><code>from prefect_shell import ShellOperation\n\nshell_operation = ShellOperation.load(\"BLOCK_NAME\")\n</code></pre></p> Source code in <code>prefect_shell/commands.py</code> <pre><code>class ShellOperation(JobBlock):\n    \"\"\"\n    A block representing a shell operation, containing multiple commands.\n\n    For long-lasting operations, use the trigger method and utilize the block as a\n    context manager for automatic closure of processes when context is exited.\n    If not, manually call the close method to close processes.\n\n    For short-lasting operations, use the run method. Context is automatically managed\n    with this method.\n\n    Attributes:\n        commands: A list of commands to execute sequentially.\n        stream_output: Whether to stream output.\n        env: A dictionary of environment variables to set for the shell operation.\n        working_dir: The working directory context the commands\n            will be executed within.\n        shell: The shell to use to execute the commands.\n        extension: The extension to use for the temporary file.\n            if unset defaults to `.ps1` on Windows and `.sh` on other platforms.\n\n    Examples:\n        Load a configured block:\n        ```python\n        from prefect_shell import ShellOperation\n\n        shell_operation = ShellOperation.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"\n\n    _block_type_name = \"Shell Operation\"\n    _logo_url = \"https://cdn.sanity.io/images/3ugk85nk/production/0b47a017e1b40381de770c17647c49cdf6388d1c-250x250.png\"  # noqa: E501\n    _documentation_url = \"https://prefecthq.github.io/prefect-shell/commands/#prefect_shell.commands.ShellOperation\"  # noqa: E501\n\n    commands: List[str] = Field(\n        default=..., description=\"A list of commands to execute sequentially.\"\n    )\n    stream_output: bool = Field(default=True, description=\"Whether to stream output.\")\n    env: Dict[str, str] = Field(\n        default_factory=dict,\n        title=\"Environment Variables\",\n        description=\"Environment variables to use for the subprocess.\",\n    )\n    working_dir: DirectoryPath = Field(\n        default=None,\n        title=\"Working Directory\",\n        description=(\n            \"The absolute path to the working directory \"\n            \"the command will be executed within.\"\n        ),\n    )\n    shell: str = Field(\n        default=None,\n        description=(\n            \"The shell to run the command with; if unset, \"\n            \"defaults to `powershell` on Windows and `bash` on other platforms.\"\n        ),\n    )\n    extension: Optional[str] = Field(\n        default=None,\n        description=(\n            \"The extension to use for the temporary file; if unset, \"\n            \"defaults to `.ps1` on Windows and `.sh` on other platforms.\"\n        ),\n    )\n\n    _exit_stack: AsyncExitStack = PrivateAttr(\n        default_factory=AsyncExitStack,\n    )\n\n    @contextmanager\n    def _prep_trigger_command(self) -&gt; Generator[str, None, None]:\n        \"\"\"\n        Write the commands to a temporary file, handling all the details of\n        creating the file and cleaning it up afterwards. Then, return the command\n        to run the temporary file.\n        \"\"\"\n        try:\n            extension = self.extension or (\".ps1\" if sys.platform == \"win32\" else \".sh\")\n            temp_file = tempfile.NamedTemporaryFile(\n                prefix=\"prefect-\",\n                suffix=extension,\n                delete=False,\n            )\n\n            joined_commands = os.linesep.join(self.commands)\n            self.logger.debug(\n                f\"Writing the following commands to \"\n                f\"{temp_file.name!r}:{os.linesep}{joined_commands}\"\n            )\n            temp_file.write(joined_commands.encode())\n\n            if self.shell is None and sys.platform == \"win32\" or extension == \".ps1\":\n                shell = \"powershell\"\n            elif self.shell is None:\n                shell = \"bash\"\n            else:\n                shell = self.shell.lower()\n\n            if shell == \"powershell\":\n                # if powershell, set exit code to that of command\n                temp_file.write(\"\\r\\nExit $LastExitCode\".encode())\n            temp_file.close()\n\n            trigger_command = [shell, temp_file.name]\n            yield trigger_command\n        finally:\n            if os.path.exists(temp_file.name):\n                os.remove(temp_file.name)\n\n    def _compile_kwargs(self, **open_kwargs: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Helper method to compile the kwargs for `open_process` so it's not repeated\n        across the run and trigger methods.\n        \"\"\"\n        trigger_command = self._exit_stack.enter_context(self._prep_trigger_command())\n        input_env = os.environ.copy()\n        input_env.update(self.env)\n        input_open_kwargs = dict(\n            command=trigger_command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            env=input_env,\n            cwd=self.working_dir,\n            **open_kwargs,\n        )\n        return input_open_kwargs\n\n    @sync_compatible\n    async def trigger(self, **open_kwargs: Dict[str, Any]) -&gt; ShellProcess:\n        \"\"\"\n        Triggers a shell command and returns the shell command run object\n        to track the execution of the run. This method is ideal for long-lasting\n        shell commands; for short-lasting shell commands, it is recommended\n        to use the `run` method instead.\n\n        Args:\n            **open_kwargs: Additional keyword arguments to pass to `open_process`.\n\n        Returns:\n            A `ShellProcess` object.\n\n        Examples:\n            Sleep for 5 seconds and then print \"Hello, world!\":\n            ```python\n            from prefect_shell import ShellOperation\n\n            with ShellOperation(\n                commands=[\"sleep 5\", \"echo 'Hello, world!'\"],\n            ) as shell_operation:\n                shell_process = shell_operation.trigger()\n                shell_process.wait_for_completion()\n                shell_output = shell_process.fetch_result()\n            ```\n        \"\"\"\n        input_open_kwargs = self._compile_kwargs(**open_kwargs)\n        process = await self._exit_stack.enter_async_context(\n            open_process(**input_open_kwargs)\n        )\n        num_commands = len(self.commands)\n        self.logger.info(\n            f\"PID {process.pid} triggered with {num_commands} commands running \"\n            f\"inside the {(self.working_dir or '.')!r} directory.\"\n        )\n        return ShellProcess(shell_operation=self, process=process)\n\n    @sync_compatible\n    async def run(self, **open_kwargs: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"\n        Runs a shell command, but unlike the trigger method,\n        additionally waits and fetches the result directly, automatically managing\n        the context. This method is ideal for short-lasting shell commands;\n        for long-lasting shell commands, it is\n        recommended to use the `trigger` method instead.\n\n        Args:\n            **open_kwargs: Additional keyword arguments to pass to `open_process`.\n\n        Returns:\n            The lines output from the shell command as a list.\n\n        Examples:\n            Sleep for 5 seconds and then print \"Hello, world!\":\n            ```python\n            from prefect_shell import ShellOperation\n\n            shell_output = ShellOperation(\n                commands=[\"sleep 5\", \"echo 'Hello, world!'\"]\n            ).run()\n            ```\n        \"\"\"\n        input_open_kwargs = self._compile_kwargs(**open_kwargs)\n        async with open_process(**input_open_kwargs) as process:\n            shell_process = ShellProcess(shell_operation=self, process=process)\n            num_commands = len(self.commands)\n            self.logger.info(\n                f\"PID {process.pid} triggered with {num_commands} commands running \"\n                f\"inside the {(self.working_dir or '.')!r} directory.\"\n            )\n            await shell_process.wait_for_completion()\n            result = await shell_process.fetch_result()\n\n        return result\n\n    @sync_compatible\n    async def close(self):\n        \"\"\"\n        Close the job block.\n        \"\"\"\n        await self._exit_stack.aclose()\n        self.logger.info(\"Successfully closed all open processes.\")\n\n    async def aclose(self):\n        \"\"\"\n        Asynchronous version of the close method.\n        \"\"\"\n        await self.close()\n\n    async def __aenter__(self) -&gt; \"ShellOperation\":\n        \"\"\"\n        Asynchronous version of the enter method.\n        \"\"\"\n        return self\n\n    async def __aexit__(self, *exc_info):\n        \"\"\"\n        Asynchronous version of the exit method.\n        \"\"\"\n        await self.close()\n\n    def __enter__(self) -&gt; \"ShellOperation\":\n        \"\"\"\n        Enter the context of the job block.\n        \"\"\"\n        return self\n\n    def __exit__(self, *exc_info):\n        \"\"\"\n        Exit the context of the job block.\n        \"\"\"\n        self.close()\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation-functions","title":"Functions","text":""},{"location":"commands/#prefect_shell.commands.ShellOperation.__aenter__","title":"<code>__aenter__</code>  <code>async</code>","text":"<p>Asynchronous version of the enter method.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>async def __aenter__(self) -&gt; \"ShellOperation\":\n    \"\"\"\n    Asynchronous version of the enter method.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.__aexit__","title":"<code>__aexit__</code>  <code>async</code>","text":"<p>Asynchronous version of the exit method.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>async def __aexit__(self, *exc_info):\n    \"\"\"\n    Asynchronous version of the exit method.\n    \"\"\"\n    await self.close()\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.__enter__","title":"<code>__enter__</code>","text":"<p>Enter the context of the job block.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>def __enter__(self) -&gt; \"ShellOperation\":\n    \"\"\"\n    Enter the context of the job block.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.__exit__","title":"<code>__exit__</code>","text":"<p>Exit the context of the job block.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>def __exit__(self, *exc_info):\n    \"\"\"\n    Exit the context of the job block.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.aclose","title":"<code>aclose</code>  <code>async</code>","text":"<p>Asynchronous version of the close method.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>async def aclose(self):\n    \"\"\"\n    Asynchronous version of the close method.\n    \"\"\"\n    await self.close()\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.close","title":"<code>close</code>  <code>async</code>","text":"<p>Close the job block.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@sync_compatible\nasync def close(self):\n    \"\"\"\n    Close the job block.\n    \"\"\"\n    await self._exit_stack.aclose()\n    self.logger.info(\"Successfully closed all open processes.\")\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.run","title":"<code>run</code>  <code>async</code>","text":"<p>Runs a shell command, but unlike the trigger method, additionally waits and fetches the result directly, automatically managing the context. This method is ideal for short-lasting shell commands; for long-lasting shell commands, it is recommended to use the <code>trigger</code> method instead.</p> <p>Parameters:</p> Name Type Description Default <code>**open_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>open_process</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>The lines output from the shell command as a list.</p> <p>Examples:</p> <p>Sleep for 5 seconds and then print \"Hello, world!\": <pre><code>from prefect_shell import ShellOperation\n\nshell_output = ShellOperation(\n    commands=[\"sleep 5\", \"echo 'Hello, world!'\"]\n).run()\n</code></pre></p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@sync_compatible\nasync def run(self, **open_kwargs: Dict[str, Any]) -&gt; List[str]:\n    \"\"\"\n    Runs a shell command, but unlike the trigger method,\n    additionally waits and fetches the result directly, automatically managing\n    the context. This method is ideal for short-lasting shell commands;\n    for long-lasting shell commands, it is\n    recommended to use the `trigger` method instead.\n\n    Args:\n        **open_kwargs: Additional keyword arguments to pass to `open_process`.\n\n    Returns:\n        The lines output from the shell command as a list.\n\n    Examples:\n        Sleep for 5 seconds and then print \"Hello, world!\":\n        ```python\n        from prefect_shell import ShellOperation\n\n        shell_output = ShellOperation(\n            commands=[\"sleep 5\", \"echo 'Hello, world!'\"]\n        ).run()\n        ```\n    \"\"\"\n    input_open_kwargs = self._compile_kwargs(**open_kwargs)\n    async with open_process(**input_open_kwargs) as process:\n        shell_process = ShellProcess(shell_operation=self, process=process)\n        num_commands = len(self.commands)\n        self.logger.info(\n            f\"PID {process.pid} triggered with {num_commands} commands running \"\n            f\"inside the {(self.working_dir or '.')!r} directory.\"\n        )\n        await shell_process.wait_for_completion()\n        result = await shell_process.fetch_result()\n\n    return result\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellOperation.trigger","title":"<code>trigger</code>  <code>async</code>","text":"<p>Triggers a shell command and returns the shell command run object to track the execution of the run. This method is ideal for long-lasting shell commands; for short-lasting shell commands, it is recommended to use the <code>run</code> method instead.</p> <p>Parameters:</p> Name Type Description Default <code>**open_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>open_process</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ShellProcess</code> <p>A <code>ShellProcess</code> object.</p> <p>Examples:</p> <p>Sleep for 5 seconds and then print \"Hello, world!\": <pre><code>from prefect_shell import ShellOperation\n\nwith ShellOperation(\n    commands=[\"sleep 5\", \"echo 'Hello, world!'\"],\n) as shell_operation:\n    shell_process = shell_operation.trigger()\n    shell_process.wait_for_completion()\n    shell_output = shell_process.fetch_result()\n</code></pre></p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@sync_compatible\nasync def trigger(self, **open_kwargs: Dict[str, Any]) -&gt; ShellProcess:\n    \"\"\"\n    Triggers a shell command and returns the shell command run object\n    to track the execution of the run. This method is ideal for long-lasting\n    shell commands; for short-lasting shell commands, it is recommended\n    to use the `run` method instead.\n\n    Args:\n        **open_kwargs: Additional keyword arguments to pass to `open_process`.\n\n    Returns:\n        A `ShellProcess` object.\n\n    Examples:\n        Sleep for 5 seconds and then print \"Hello, world!\":\n        ```python\n        from prefect_shell import ShellOperation\n\n        with ShellOperation(\n            commands=[\"sleep 5\", \"echo 'Hello, world!'\"],\n        ) as shell_operation:\n            shell_process = shell_operation.trigger()\n            shell_process.wait_for_completion()\n            shell_output = shell_process.fetch_result()\n        ```\n    \"\"\"\n    input_open_kwargs = self._compile_kwargs(**open_kwargs)\n    process = await self._exit_stack.enter_async_context(\n        open_process(**input_open_kwargs)\n    )\n    num_commands = len(self.commands)\n    self.logger.info(\n        f\"PID {process.pid} triggered with {num_commands} commands running \"\n        f\"inside the {(self.working_dir or '.')!r} directory.\"\n    )\n    return ShellProcess(shell_operation=self, process=process)\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellProcess","title":"<code>ShellProcess</code>","text":"<p>             Bases: <code>JobRun</code></p> <p>A class representing a shell process.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>class ShellProcess(JobRun):\n    \"\"\"\n    A class representing a shell process.\n    \"\"\"\n\n    def __init__(self, shell_operation: \"ShellOperation\", process: Process):\n        self._shell_operation = shell_operation\n        self._process = process\n        self._output = []\n\n    @property\n    def pid(self) -&gt; int:\n        \"\"\"\n        The PID of the process.\n\n        Returns:\n            The PID of the process.\n        \"\"\"\n        return self._process.pid\n\n    @property\n    def return_code(self) -&gt; Optional[int]:\n        \"\"\"\n        The return code of the process.\n\n        Returns:\n            The return code of the process, or `None` if the process is still running.\n        \"\"\"\n        return self._process.returncode\n\n    async def _capture_output(self, source):\n        \"\"\"\n        Capture output from source.\n        \"\"\"\n        async for output in TextReceiveStream(source):\n            text = output.rstrip()\n            if self._shell_operation.stream_output:\n                self.logger.info(f\"PID {self.pid} stream output:{os.linesep}{text}\")\n            self._output.extend(text.split(os.linesep))\n\n    @sync_compatible\n    async def wait_for_completion(self) -&gt; None:\n        \"\"\"\n        Wait for the shell command to complete after a process is triggered.\n        \"\"\"\n        self.logger.debug(f\"Waiting for PID {self.pid} to complete.\")\n\n        await asyncio.gather(\n            self._capture_output(self._process.stdout),\n            self._capture_output(self._process.stderr),\n        )\n        await self._process.wait()\n\n        if self.return_code != 0:\n            raise RuntimeError(\n                f\"PID {self.pid} failed with return code {self.return_code}.\"\n            )\n        self.logger.info(\n            f\"PID {self.pid} completed with return code {self.return_code}.\"\n        )\n\n    @sync_compatible\n    async def fetch_result(self) -&gt; List[str]:\n        \"\"\"\n        Retrieve the output of the shell operation.\n\n        Returns:\n            The lines output from the shell operation as a list.\n        \"\"\"\n        if self._process.returncode is None:\n            self.logger.info(\"Process is still running, result may be incomplete.\")\n        return self._output\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellProcess-attributes","title":"Attributes","text":""},{"location":"commands/#prefect_shell.commands.ShellProcess.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>The PID of the process.</p> <p>Returns:</p> Type Description <code>int</code> <p>The PID of the process.</p>"},{"location":"commands/#prefect_shell.commands.ShellProcess.return_code","title":"<code>return_code: Optional[int]</code>  <code>property</code>","text":"<p>The return code of the process.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The return code of the process, or <code>None</code> if the process is still running.</p>"},{"location":"commands/#prefect_shell.commands.ShellProcess-functions","title":"Functions","text":""},{"location":"commands/#prefect_shell.commands.ShellProcess.fetch_result","title":"<code>fetch_result</code>  <code>async</code>","text":"<p>Retrieve the output of the shell operation.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The lines output from the shell operation as a list.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@sync_compatible\nasync def fetch_result(self) -&gt; List[str]:\n    \"\"\"\n    Retrieve the output of the shell operation.\n\n    Returns:\n        The lines output from the shell operation as a list.\n    \"\"\"\n    if self._process.returncode is None:\n        self.logger.info(\"Process is still running, result may be incomplete.\")\n    return self._output\n</code></pre>"},{"location":"commands/#prefect_shell.commands.ShellProcess.wait_for_completion","title":"<code>wait_for_completion</code>  <code>async</code>","text":"<p>Wait for the shell command to complete after a process is triggered.</p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@sync_compatible\nasync def wait_for_completion(self) -&gt; None:\n    \"\"\"\n    Wait for the shell command to complete after a process is triggered.\n    \"\"\"\n    self.logger.debug(f\"Waiting for PID {self.pid} to complete.\")\n\n    await asyncio.gather(\n        self._capture_output(self._process.stdout),\n        self._capture_output(self._process.stderr),\n    )\n    await self._process.wait()\n\n    if self.return_code != 0:\n        raise RuntimeError(\n            f\"PID {self.pid} failed with return code {self.return_code}.\"\n        )\n    self.logger.info(\n        f\"PID {self.pid} completed with return code {self.return_code}.\"\n    )\n</code></pre>"},{"location":"commands/#prefect_shell.commands-functions","title":"Functions","text":""},{"location":"commands/#prefect_shell.commands.shell_run_command","title":"<code>shell_run_command</code>  <code>async</code>","text":"<p>Runs arbitrary shell commands.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to be executed; can also be provided post-initialization by calling this task instance.</p> required <code>env</code> <code>Optional[dict]</code> <p>Dictionary of environment variables to use for the subprocess; can also be provided at runtime.</p> <code>None</code> <code>helper_command</code> <code>Optional[str]</code> <p>String representing a shell command, which will be executed prior to the <code>command</code> in the same process. Can be used to change directories, define helper functions, etc. for different commands in a flow.</p> <code>None</code> <code>shell</code> <code>Optional[str]</code> <p>Shell to run the command with.</p> <code>None</code> <code>extension</code> <code>Optional[str]</code> <p>File extension to be appended to the command to be executed.</p> <code>None</code> <code>return_all</code> <code>bool</code> <p>Whether this task should return all lines of stdout as a list, or just the last line as a string.</p> <code>False</code> <code>stream_level</code> <code>int</code> <p>The logging level of the stream; defaults to 20 equivalent to <code>logging.INFO</code>.</p> <code>INFO</code> <code>cwd</code> <code>Union[str, bytes, PathLike, None]</code> <p>The working directory context the command will be executed within</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[List, str]</code> <p>If return all, returns all lines as a list; else the last line as a string.</p> Example <p>List contents in the current directory. <pre><code>from prefect import flow\nfrom prefect_shell import shell_run_command\n\n@flow\ndef example_shell_run_command_flow():\n    return shell_run_command(command=\"ls .\", return_all=True)\n\nexample_shell_run_command_flow()\n</code></pre></p> Source code in <code>prefect_shell/commands.py</code> <pre><code>@task\nasync def shell_run_command(\n    command: str,\n    env: Optional[dict] = None,\n    helper_command: Optional[str] = None,\n    shell: Optional[str] = None,\n    extension: Optional[str] = None,\n    return_all: bool = False,\n    stream_level: int = logging.INFO,\n    cwd: Union[str, bytes, os.PathLike, None] = None,\n) -&gt; Union[List, str]:\n    \"\"\"\n    Runs arbitrary shell commands.\n\n    Args:\n        command: Shell command to be executed; can also be\n            provided post-initialization by calling this task instance.\n        env: Dictionary of environment variables to use for\n            the subprocess; can also be provided at runtime.\n        helper_command: String representing a shell command, which\n            will be executed prior to the `command` in the same process.\n            Can be used to change directories, define helper functions, etc.\n            for different commands in a flow.\n        shell: Shell to run the command with.\n        extension: File extension to be appended to the command to be executed.\n        return_all: Whether this task should return all lines of stdout as a list,\n            or just the last line as a string.\n        stream_level: The logging level of the stream;\n            defaults to 20 equivalent to `logging.INFO`.\n        cwd: The working directory context the command will be executed within\n\n    Returns:\n        If return all, returns all lines as a list; else the last line as a string.\n\n    Example:\n        List contents in the current directory.\n        ```python\n        from prefect import flow\n        from prefect_shell import shell_run_command\n\n        @flow\n        def example_shell_run_command_flow():\n            return shell_run_command(command=\"ls .\", return_all=True)\n\n        example_shell_run_command_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    current_env = os.environ.copy()\n    current_env.update(env or {})\n\n    if shell is None:\n        # if shell is not specified:\n        # use powershell for windows\n        # use bash for other platforms\n        shell = \"powershell\" if sys.platform == \"win32\" else \"bash\"\n\n    extension = \".ps1\" if shell.lower() == \"powershell\" else extension\n\n    tmp = tempfile.NamedTemporaryFile(prefix=\"prefect-\", suffix=extension, delete=False)\n    try:\n        if helper_command:\n            tmp.write(helper_command.encode())\n            tmp.write(os.linesep.encode())\n        tmp.write(command.encode())\n        if shell.lower() == \"powershell\":\n            # if powershell, set exit code to that of command\n            tmp.write(\"\\r\\nExit $LastExitCode\".encode())\n        tmp.close()\n\n        shell_command = [shell, tmp.name]\n\n        lines = []\n        async with await anyio.open_process(\n            shell_command, env=current_env, cwd=cwd\n        ) as process:\n            async for text in TextReceiveStream(process.stdout):\n                logger.log(level=stream_level, msg=text)\n                lines.extend(text.rstrip().split(\"\\n\"))\n\n            await process.wait()\n            if process.returncode:\n                stderr = \"\\n\".join(\n                    [text async for text in TextReceiveStream(process.stderr)]\n                )\n                if not stderr and lines:\n                    stderr = f\"{lines[-1]}\\n\"\n                msg = (\n                    f\"Command failed with exit code {process.returncode}:\\n\" f\"{stderr}\"\n                )\n                raise RuntimeError(msg)\n    finally:\n        if os.path.exists(tmp.name):\n            os.remove(tmp.name)\n\n    line = lines[-1] if lines else \"\"\n    return lines if return_all else line\n</code></pre>"},{"location":"examples_catalog/","title":"Examples Catalog","text":"<p>Below is a list of examples for <code>prefect-shell</code>.</p>"},{"location":"examples_catalog/#commands-module","title":"Commands Module","text":"<p>Sleep for 5 seconds and then print \"Hello, world!\": <pre><code>from prefect_shell import ShellOperation\n\nshell_output = ShellOperation(\n    commands=[\"sleep 5\", \"echo 'Hello, world!'\"]\n).run()\n</code></pre> Sleep for 5 seconds and then print \"Hello, world!\": <pre><code>from prefect_shell import ShellOperation\n\nwith ShellOperation(\n    commands=[\"sleep 5\", \"echo 'Hello, world!'\"],\n) as shell_operation:\n    shell_process = shell_operation.trigger()\n    shell_process.wait_for_completion()\n    shell_output = shell_process.fetch_result()\n</code></pre></p>"}]}