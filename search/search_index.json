{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-shell Welcome! prefect-shell is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows. Getting Started Python setup Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-shell with pip : pip install -U prefect-shell Write and run a flow from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow (): return shell_run_command ( command = \"ls .\" , return_all = True ) example_shell_run_command_flow () Resources If you encounter any bugs while using prefect-shell , feel free to open an issue in the prefect-shell repository. If you have any questions or issues while using prefect-shell , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to star or watch prefect-shell for updates too! Development If you'd like to install a version of prefect-shell for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-shell.git cd prefect-shell/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Home"},{"location":"#prefect-shell","text":"","title":"prefect-shell"},{"location":"#welcome","text":"prefect-shell is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-shell with pip : pip install -U prefect-shell","title":"Installation"},{"location":"#write-and-run-a-flow","text":"from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow (): return shell_run_command ( command = \"ls .\" , return_all = True ) example_shell_run_command_flow ()","title":"Write and run a flow"},{"location":"#resources","text":"If you encounter any bugs while using prefect-shell , feel free to open an issue in the prefect-shell repository. If you have any questions or issues while using prefect-shell , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to star or watch prefect-shell for updates too!","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-shell for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-shell.git cd prefect-shell/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Development"},{"location":"commands/","text":"prefect_shell.commands Tasks for interacting with shell commands Functions shell_run_command async Runs arbitrary shell commands. Parameters: Name Type Description Default command str Shell command to be executed; can also be provided post-initialization by calling this task instance. required env Optional [ dict ] Dictionary of environment variables to use for the subprocess; can also be provided at runtime. None helper_command Optional [ str ] String representing a shell command, which will be executed prior to the command in the same process. Can be used to change directories, define helper functions, etc. for different commands in a flow. None shell Optional [ str ] Shell to run the command with. None extension Optional [ str ] File extension to be appended to the command to be executed. None return_all bool Whether this task should return all lines of stdout as a list, or just the last line as a string. False stream_level int The logging level of the stream; defaults to 20 equivalent to logging.INFO . logging.INFO cwd Union [ str , bytes , os . PathLike , None] The working directory context the command will be executed within None Returns: Type Description Union [ List , str ] If return all, returns all lines as a list; else the last line as a string. Example List contents in the current directory. from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow (): return shell_run_command ( command = \"ls .\" , return_all = True ) example_shell_run_command_flow () Source code in prefect_shell/commands.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @task async def shell_run_command ( command : str , env : Optional [ dict ] = None , helper_command : Optional [ str ] = None , shell : Optional [ str ] = None , extension : Optional [ str ] = None , return_all : bool = False , stream_level : int = logging . INFO , cwd : Union [ str , bytes , os . PathLike , None ] = None , ) -> Union [ List , str ]: \"\"\" Runs arbitrary shell commands. Args: command: Shell command to be executed; can also be provided post-initialization by calling this task instance. env: Dictionary of environment variables to use for the subprocess; can also be provided at runtime. helper_command: String representing a shell command, which will be executed prior to the `command` in the same process. Can be used to change directories, define helper functions, etc. for different commands in a flow. shell: Shell to run the command with. extension: File extension to be appended to the command to be executed. return_all: Whether this task should return all lines of stdout as a list, or just the last line as a string. stream_level: The logging level of the stream; defaults to 20 equivalent to `logging.INFO`. cwd: The working directory context the command will be executed within Returns: If return all, returns all lines as a list; else the last line as a string. Example: List contents in the current directory. ```python from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow(): return shell_run_command(command=\"ls .\", return_all=True) example_shell_run_command_flow() ``` \"\"\" logger = get_run_logger () current_env = os . environ . copy () current_env . update ( env or {}) if shell is None : # if shell is not specified: # use powershell for windows # use bash for other platforms shell = \"powershell\" if sys . platform == \"win32\" else \"bash\" extension = \".ps1\" if shell . lower () == \"powershell\" else extension tmp = tempfile . NamedTemporaryFile ( prefix = \"prefect-\" , suffix = extension , delete = False ) try : if helper_command : tmp . write ( helper_command . encode ()) tmp . write ( os . linesep . encode ()) tmp . write ( command . encode ()) tmp . close () shell_command = [ shell , tmp . name ] lines = [] async with await open_process ( shell_command , env = current_env , cwd = cwd ) as process : async for text in TextReceiveStream ( process . stdout ): logger . log ( level = stream_level , msg = text ) lines . extend ( text . rstrip () . split ( \" \\n \" )) await process . wait () if process . returncode : stderr = \" \\n \" . join ( [ text async for text in TextReceiveStream ( process . stderr )] ) if not stderr and lines : stderr = f \" { lines [ - 1 ] } \\n \" msg = ( f \"Command failed with exit code { process . returncode } : \\n \" f \" { stderr } \" ) raise RuntimeError ( msg ) finally : if os . path . exists ( tmp . name ): os . remove ( tmp . name ) line = lines [ - 1 ] if lines else \"\" return lines if return_all else line","title":"Commands"},{"location":"commands/#prefect_shell.commands","text":"Tasks for interacting with shell commands","title":"commands"},{"location":"commands/#prefect_shell.commands-functions","text":"","title":"Functions"},{"location":"commands/#prefect_shell.commands.shell_run_command","text":"Runs arbitrary shell commands. Parameters: Name Type Description Default command str Shell command to be executed; can also be provided post-initialization by calling this task instance. required env Optional [ dict ] Dictionary of environment variables to use for the subprocess; can also be provided at runtime. None helper_command Optional [ str ] String representing a shell command, which will be executed prior to the command in the same process. Can be used to change directories, define helper functions, etc. for different commands in a flow. None shell Optional [ str ] Shell to run the command with. None extension Optional [ str ] File extension to be appended to the command to be executed. None return_all bool Whether this task should return all lines of stdout as a list, or just the last line as a string. False stream_level int The logging level of the stream; defaults to 20 equivalent to logging.INFO . logging.INFO cwd Union [ str , bytes , os . PathLike , None] The working directory context the command will be executed within None Returns: Type Description Union [ List , str ] If return all, returns all lines as a list; else the last line as a string. Example List contents in the current directory. from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow (): return shell_run_command ( command = \"ls .\" , return_all = True ) example_shell_run_command_flow () Source code in prefect_shell/commands.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @task async def shell_run_command ( command : str , env : Optional [ dict ] = None , helper_command : Optional [ str ] = None , shell : Optional [ str ] = None , extension : Optional [ str ] = None , return_all : bool = False , stream_level : int = logging . INFO , cwd : Union [ str , bytes , os . PathLike , None ] = None , ) -> Union [ List , str ]: \"\"\" Runs arbitrary shell commands. Args: command: Shell command to be executed; can also be provided post-initialization by calling this task instance. env: Dictionary of environment variables to use for the subprocess; can also be provided at runtime. helper_command: String representing a shell command, which will be executed prior to the `command` in the same process. Can be used to change directories, define helper functions, etc. for different commands in a flow. shell: Shell to run the command with. extension: File extension to be appended to the command to be executed. return_all: Whether this task should return all lines of stdout as a list, or just the last line as a string. stream_level: The logging level of the stream; defaults to 20 equivalent to `logging.INFO`. cwd: The working directory context the command will be executed within Returns: If return all, returns all lines as a list; else the last line as a string. Example: List contents in the current directory. ```python from prefect import flow from prefect_shell import shell_run_command @flow def example_shell_run_command_flow(): return shell_run_command(command=\"ls .\", return_all=True) example_shell_run_command_flow() ``` \"\"\" logger = get_run_logger () current_env = os . environ . copy () current_env . update ( env or {}) if shell is None : # if shell is not specified: # use powershell for windows # use bash for other platforms shell = \"powershell\" if sys . platform == \"win32\" else \"bash\" extension = \".ps1\" if shell . lower () == \"powershell\" else extension tmp = tempfile . NamedTemporaryFile ( prefix = \"prefect-\" , suffix = extension , delete = False ) try : if helper_command : tmp . write ( helper_command . encode ()) tmp . write ( os . linesep . encode ()) tmp . write ( command . encode ()) tmp . close () shell_command = [ shell , tmp . name ] lines = [] async with await open_process ( shell_command , env = current_env , cwd = cwd ) as process : async for text in TextReceiveStream ( process . stdout ): logger . log ( level = stream_level , msg = text ) lines . extend ( text . rstrip () . split ( \" \\n \" )) await process . wait () if process . returncode : stderr = \" \\n \" . join ( [ text async for text in TextReceiveStream ( process . stderr )] ) if not stderr and lines : stderr = f \" { lines [ - 1 ] } \\n \" msg = ( f \"Command failed with exit code { process . returncode } : \\n \" f \" { stderr } \" ) raise RuntimeError ( msg ) finally : if os . path . exists ( tmp . name ): os . remove ( tmp . name ) line = lines [ - 1 ] if lines else \"\" return lines if return_all else line","title":"shell_run_command()"}]}